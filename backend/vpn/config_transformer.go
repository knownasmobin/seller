package vpn

import (
	"regexp"
	"strings"
)

// TransformWGConfig takes the raw wgportal config and transforms it into
// a clean user-facing config with:
// - Custom header comment
// - WGP metadata comments stripped
// - Endpoint replaced with user-selected endpoint
// - AllowedIPs set to 0.0.0.0/0 for full tunnel
// - WireSock extensions appended (if wireSockAllowedApps is not empty)
func TransformWGConfig(rawConfig string, botName string, selectedEndpoint string, wireSockAllowedApps string) string {
	lines := strings.Split(rawConfig, "\n")
	var result []string

	// Add custom header
	result = append(result, "#"+botName)

	// Regex patterns for lines to strip
	wgpPattern := regexp.MustCompile(`^#\s*-WGP-`)
	autogenPattern := regexp.MustCompile(`^#\s*(AUTOGENERATED|This file uses|See https://|Lines starting|the WireGuard Portal)`)
	commentOnlyPattern := regexp.MustCompile(`^#\s*(Core settings|Misc\. settings|Interface hooks)`)

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Skip WGP metadata comments
		if wgpPattern.MatchString(trimmed) {
			continue
		}

		// Skip autogenerated header comments
		if autogenPattern.MatchString(trimmed) {
			continue
		}

		// Skip section helper comments
		if commentOnlyPattern.MatchString(trimmed) {
			continue
		}

		// Skip empty comment lines that were just separators
		if trimmed == "#" {
			continue
		}

		// Replace Endpoint with user-selected one
		if strings.HasPrefix(trimmed, "Endpoint") && selectedEndpoint != "" {
			result = append(result, "Endpoint = "+selectedEndpoint)
			continue
		}

		// Replace AllowedIPs with full tunnel
		if strings.HasPrefix(trimmed, "AllowedIPs") {
			result = append(result, "AllowedIPs = 0.0.0.0/0")
			continue
		}

		result = append(result, line)
	}

	// Append WireSock extensions if AllowedApps list is provided
	if wireSockAllowedApps != "" {
		result = append(result, "# [Peer] WireSock extensions")
		result = append(result, "#@ws:AllowedApps = "+wireSockAllowedApps)
	}

	// Clean up excessive blank lines
	cleaned := strings.Join(result, "\n")
	multiNewline := regexp.MustCompile(`\n{3,}`)
	cleaned = multiNewline.ReplaceAllString(cleaned, "\n\n")

	return strings.TrimSpace(cleaned)
}
